{"version":3,"file":"build.js","sources":["../node_modules/coreds/lib/util.js"],"sourcesContent":["export var hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function noop() { return null; }\n/**\n * Define a property that should not be discoverable.\n * Returns the value\n */\nexport function defp(obj, prop, val) {\n    Object.defineProperty(obj, prop, {\n        enumerable: false,\n        configurable: true,\n        value: val\n    });\n    return val;\n}\n/**\n * Set a property.\n * Returns the object\n */\nexport function setp(obj, prop, val) {\n    obj[prop] = val;\n    return obj;\n}\n/**\n * Nullify property.\n * Useful for lazy observable properties that bypasses typescript's strictNullChecks config.\n */\nexport function nullp(obj, prop) {\n    obj[prop] = null;\n}\nexport function extractMsg(data) {\n    return Array.isArray(data) ? data[1]['1'] : String(data);\n}\n/**\n * Returns the new state.\n */\nexport function bit_unset(state, value) {\n    return state & (~value & 2147483647);\n}\n/**\n * Sets the new state.\n */\n/*export function $bit_unset(obj: any, name: string, value: number) {\n    obj[name] &= (~value & 2147483647)\n}*/\n/**\n * Returns the new state.\n */\nexport function bit_clear_and_set(state, clear, set) {\n    return set | (state & (~clear & 2147483647));\n}\n/**\n * Sets the new state.\n */\n/*export function $bit_clear_and_set(obj: any, name: string, clear: number, set: number) {\n    obj[name] = set | (obj[name] & (~clear & 2147483647))\n}*/\nexport function to_flag(field) {\n    return 1 << (field - 1);\n}\nexport function to_int32(bytes, i) {\n    return ((bytes[i] & 0xFF) << 24) | ((bytes[i + 1] & 0xFF) << 16) | ((bytes[i + 2] & 0xFF) << 8) | (bytes[i + 3] & 0xFF);\n}\nexport function to_int32LE(bytes, i) {\n    return ((bytes[i + 3] & 0xFF) << 24) | ((bytes[i + 2] & 0xFF) << 16) | ((bytes[i + 1] & 0xFF) << 8) | (bytes[i] & 0xFF);\n}\nvar base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfunction b_to_b64(bytes) {\n    for (var base64 = [], i = 0; i < bytes.length; i += 3) {\n        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        for (var j = 0; j < 4; j++) {\n            if (i * 8 + j * 6 <= bytes.length * 8)\n                base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));\n            else\n                base64.push('=');\n        }\n    }\n    return base64.join('');\n}\nfunction b_to_b64_fn() {\n    var b = window['Binary'], b2a = window.btoa, b2s;\n    if (b && (b2s = b['bytesToString']) && typeof b2s === 'function' && typeof b2a === 'function') {\n        return function (bytes) {\n            return b2a(b2s(bytes));\n        };\n    }\n    return b_to_b64;\n}\nfunction b64_to_b(base64) {\n    // Remove non-base-64 characters\n    base64 = base64.replace(/[^A-Z0-9+\\/]/ig, '');\n    for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {\n        if (imod4 === 0)\n            continue;\n        bytes.push(((base64map.indexOf(base64.charAt(i - 1)) & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2)) | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));\n    }\n    return bytes;\n}\nfunction b64_to_b_fn() {\n    var b = window['Binary'], a2b = window.atob, s2b;\n    if (b && (s2b = b['stringToBytes']) && typeof s2b === 'function' && typeof a2b === 'function') {\n        return function (base64) {\n            return s2b(a2b(base64));\n        };\n    }\n    return b64_to_b;\n}\nexport var bytesToBase64 = b_to_b64_fn();\nexport var base64ToBytes = b64_to_b_fn();\nvar ZERO_KEY = 'AAAAAAAAAAAA';\nexport var regexKey = /^[A-Za-z0-9+/]+$/, regexInt = /^-?[0-9]+$/, regexDouble = /^-?[0-9]+(\\.[0-9]+)?$/, regexTime = /^[0-2]?[0-9]\\:[0-5][0-9](\\:[0-5][0-9])?$/, regexDate = /^[1-9][0-9][0-9][0-9]\\/[0-9][0-9]\\/[0-9][0-9]$/, regexDateTime = /^[1-9][0-9][0-9][0-9]\\/[0-9][0-9]\\/[0-9][0-9] [0-2]?[0-9]\\:[0-5][0-9]\\:[0-5][0-9]$/;\nfunction getDateUTCOffset(date) {\n    var n = date.getTimezoneOffset() * -10 / 6, r;\n    if (n < 0) {\n        r = (n - 10000).toString();\n        return r.charAt(0) + r.substr(2);\n    }\n    else {\n        r = (n + 10000).toString();\n        return '+' + r.substr(1);\n    }\n}\nexport function getUTCOffset() {\n    var date = new Date();\n    date.setHours(0);\n    date.setMinutes(0);\n    date.setSeconds(0);\n    date.setMilliseconds(0);\n    var offset = getDateUTCOffset(date);\n    if (offset.indexOf('+') === 0) {\n        return parseInt(offset.substring(1, offset.length - 2), 10);\n    }\n    else if (offset.indexOf('-') === 0) {\n        return -parseInt(offset.substring(1, offset.length - 2), 10);\n    }\n    else {\n        /*\n            * IE in some cases will return this value starting with undefined.  That means\n            * negative.\n            */\n        return -parseInt(offset.substring(10, offset.length - 2), 10);\n    }\n}\n/*export function now(): number {\n    return Date.now()\n}*/\nexport var MILLIS_PER_DAY = 1000 * 60 * 60 * 24, MAX_TIME_IN_MILLIS_PER_DAY = (1000 * 60 * 60 * 24) - 1, MILLIS_PER_HOUR = 1000 * 60 * 60, UTC_OFFSET = getUTCOffset(), HOST_RAW_OFFSET = UTC_OFFSET * 60 * 60 * 1000, HOST_RAW_OFFSET_SECONDS = UTC_OFFSET * 60 * 60, SECONDS_PER_HOUR = 60 * 60;\nexport function hour(h) {\n    return h * SECONDS_PER_HOUR;\n}\nexport function minute(m) {\n    return m * 60;\n}\nexport var MAX_TIME = hour(23) + minute(59) + 59;\nexport function localToUtc(ts) {\n    return ts + HOST_RAW_OFFSET;\n}\nexport function localToUtcSeconds(s) {\n    return s + HOST_RAW_OFFSET_SECONDS;\n}\nexport function utcToLocal(ts) {\n    return ts - HOST_RAW_OFFSET;\n}\nexport function utcToLocalSeconds(s) {\n    return s - HOST_RAW_OFFSET_SECONDS;\n}\nexport function extractTime(ts, date) {\n    return Math.floor((localToUtc(ts) - date) / 1000);\n}\nexport function isExpired(value, duration) {\n    return Date.now() > (value + duration);\n}\nexport function isExpired24Hrs(value) {\n    return isExpired(value, MILLIS_PER_DAY);\n}\nexport function startOfDayMS(ts) {\n    ts += HOST_RAW_OFFSET;\n    return ts - (ts % MILLIS_PER_DAY);\n}\nexport function isSameDay(ts1, ts2) {\n    return startOfDayMS(ts1) === startOfDayMS(ts2);\n}\nexport function addDaysTo(ts, days) {\n    return ts + (MILLIS_PER_DAY * days);\n}\nexport function startOfTodayMS() {\n    return startOfDayMS(Date.now());\n}\n/*export function startOfUTCTodayMS(): number {\n    return startOfDayMS(Date.now())//startOfDayMS(localDateToUTC(new Date()))\n}*/\nexport function utcNow() {\n    return Date.now() + HOST_RAW_OFFSET;\n}\n// =====================================\nexport function getKind(key) {\n    var bytes = base64ToBytes(key);\n    return bytes[bytes.length - 9] & 0xFF;\n}\nexport function isZeroKey(key) {\n    return ZERO_KEY === key;\n}\nexport function isKey(key, kind) {\n    return regexKey.test(key) && (!kind || kind === getKind(key));\n}\nfunction bytesTo6ByteTS(bytes, o) {\n    var left = (((bytes[o++] & 0xFF) << 24) | ((bytes[o++] & 0xFF) << 16)), right = (((bytes[o++] & 0xFF) << 24) | ((bytes[o++] & 0xFF) << 16) | ((bytes[o++] & 0xFF) << 8) | (bytes[o] & 0xFF));\n    left = left >>> 0;\n    right = right >>> 0;\n    // 24 is the max left shift, hence this slow operation.\n    for (var i = 0; i < 16; i++)\n        left = left * 2;\n    return left + right;\n}\nexport function getTs(key) {\n    var bytes = base64ToBytes(key);\n    switch (bytes.length) {\n        case 9: return bytesTo6ByteTS(bytes, 1);\n        case 18: return bytesTo6ByteTS(bytes, 10);\n        default: return 0;\n    }\n}\nexport function incrementKey(key) {\n    var decoded = base64ToBytes(key);\n    decoded[decoded.length - 1] |= 0x02;\n    return bytesToBase64(decoded);\n}\nexport function decrementKey(key) {\n    var decoded = base64ToBytes(key);\n    decoded[decoded.length - 1] &= 0xFE;\n    return bytesToBase64(decoded);\n}\n// from gwt JsonUtils\nvar out = [\n    \"\\\\u0000\", \"\\\\u0001\", \"\\\\u0002\", \"\\\\u0003\", \"\\\\u0004\", \"\\\\u0005\",\n    \"\\\\u0006\", \"\\\\u0007\", \"\\\\b\", \"\\\\t\", \"\\\\n\", \"\\\\u000B\",\n    \"\\\\f\", \"\\\\r\", \"\\\\u000E\", \"\\\\u000F\", \"\\\\u0010\", \"\\\\u0011\",\n    \"\\\\u0012\", \"\\\\u0013\", \"\\\\u0014\", \"\\\\u0015\", \"\\\\u0016\", \"\\\\u0017\",\n    \"\\\\u0018\", \"\\\\u0019\", \"\\\\u001A\", \"\\\\u001B\", \"\\\\u001C\", \"\\\\u001D\",\n    \"\\\\u001E\", \"\\\\u001F\"\n];\nout[34] = '\\\\\"';\nout[92] = '\\\\\\\\';\nout[0xad] = '\\\\u00ad'; // Soft hyphen\nout[0x600] = '\\\\u0600'; // Arabic number sign\nout[0x601] = '\\\\u0601'; // Arabic sign sanah\nout[0x602] = '\\\\u0602'; // Arabic footnote marker\nout[0x603] = '\\\\u0603'; // Arabic sign safha\nout[0x6dd] = '\\\\u06dd'; // Arabic and of ayah\nout[0x70f] = '\\\\u070f'; // Syriac abbreviation mark\nout[0x17b4] = '\\\\u17b4'; // Khmer vowel inherent aq\nout[0x17b5] = '\\\\u17b5'; // Khmer vowel inherent aa\nout[0x200b] = '\\\\u200b'; // Zero width space\nout[0x200c] = '\\\\u200c'; // Zero width non-joiner\nout[0x200d] = '\\\\u200d'; // Zero width joiner\nout[0x200e] = '\\\\u200e'; // Left-to-right mark\nout[0x200f] = '\\\\u200f'; // Right-to-left mark\nout[0x2028] = '\\\\u2028'; // Line separator\nout[0x2029] = '\\\\u2029'; // Paragraph separator\nout[0x202a] = '\\\\u202a'; // Left-to-right embedding\nout[0x202b] = '\\\\u202b'; // Right-to-left embedding\nout[0x202c] = '\\\\u202c'; // Pop directional formatting\nout[0x202d] = '\\\\u202d'; // Left-to-right override\nout[0x202e] = '\\\\u202e'; // Right-to-left override\nout[0x2060] = '\\\\u2060'; // Word joiner\nout[0x2061] = '\\\\u2061'; // Function application\nout[0x2062] = '\\\\u2062'; // Invisible times\nout[0x2063] = '\\\\u2063'; // Invisible separator\nout[0x2064] = '\\\\u2064'; // Invisible plus\nout[0x206a] = '\\\\u206a'; // Inhibit symmetric swapping\nout[0x206b] = '\\\\u206b'; // Activate symmetric swapping\nout[0x206c] = '\\\\u206c'; // Inherent Arabic form shaping\nout[0x206d] = '\\\\u206d'; // Activate Arabic form shaping\nout[0x206e] = '\\\\u206e'; // National digit shapes\nout[0x206f] = '\\\\u206f'; // Nominal digit shapes\nout[0xfeff] = '\\\\ufeff'; // Zero width no-break space\nout[0xfff9] = '\\\\ufff9'; // Intralinear annotation anchor\nout[0xfffa] = '\\\\ufffa'; // Intralinear annotation separator\nout[0xfffb] = '\\\\ufffb'; // Intralinear annotation terminator\nvar regexEscape = /[\\x00-\\x1f\\xad\\u0600-\\u0603\\u06dd\\u070f\\u17b4\\u17b5\\u200b-\\u200f\\u2028-\\u202e\\u2060-\\u2064\\u206a-\\u206f\\ufeff\\ufff9-\\ufffb\"\\\\]/g;\nfunction escapeChar(c) {\n    return out[c.charCodeAt(0)] || c;\n}\nexport function $escape(str) {\n    return str.replace(regexEscape, escapeChar);\n}\n/**\n * Returns a double-quoted string for json.\n */\nexport function escapeValue(v) {\n    return '\"' + $escape(v) + '\"';\n}\n//# sourceMappingURL=util.js.map"],"names":[],"mappings":"AA6BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}